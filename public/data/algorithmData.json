{
  "BubbleSort": {
    "title": "Bubble Sort",
    "metaTitle": "Bubble Sort | Algoviz",
    "description": "Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.",
    "code": "void bubbleSort(int arr[], int n){\n\tint i, j;\n\tfor (i = 0; i < n - 1; i++)\n\t\tfor (j = 0; j < n - i - 1; j++)\n\t\t\tif (arr[j] > arr[j + 1]) \n\t\t\t\tswap(&arr[j], &arr[j + 1]);\n}",
    "timeComplexity": {
      "best": "O(n)",
      "average": "O(n^2)",
      "worst": "O(n^2)"
    },
    "spaceComplexity": {
      "best": "O(1)",
      "average": "O(1)",
      "worst": "O(1)"
    },
    "stable": "YES"
  },
  "InsertionSort": {
    "title": "Insertion Sort",
    "metaTitle": "Insertion Sort | Algoviz",
    "description": "Insertion sort is a simple sorting algorithm that works the way we sort playing cards in our hands.",
    "code": "void insertionSort(int arr[], int n){\n\tint i, key, j;\n\tfor (i = 1; i < n; i++){\n\t\tkey = arr[i];\n\t\tj = i - 1;\n\t\twhile (j >= 0 && arr[j] > key){\n\t\t\tarr[j + 1] = arr[j];\n\t\t\tj = j - 1;\n\t\t}\n\t\tarr[j + 1] = key;\n\t}\n}",
    "timeComplexity": {
      "best": "O(n)",
      "average": "O(n^2)",
      "worst": "O(n^2)"
    },
    "spaceComplexity": {
      "best": "O(1)",
      "average": "O(1)",
      "worst": "O(1)"
    },
    "stable": "YES"
  },
  "SelectionSort": {
    "title": "Selection Sort",
    "metaTitle": "Selection Sort | Algoviz",
    "description": "Selection sort is an in-place comparison sorting algorithm. It has an O(n2) time complexity, which makes it inefficient on large lists, and generally performs worse than the similar insertion sort.",
    "code": "void selectionSort(int arr[], int n){\n\tint i, j, min_idx;\n\tfor (i = 0; i < n - 1; i++){\n\t\tmin_idx = i;\n\t\tfor (j = i + 1; j < n; j++)\n\t\t\tif (arr[j] < arr[min_idx]) min_idx = j;\n\t\tswap(&arr[min_idx], &arr[i]);\n\t}\n}",
    "timeComplexity": {
      "best": "O(n^2)",
      "average": "O(n^2)",
      "worst": "O(n^2)"
    },
    "spaceComplexity": {
      "best": "O(1)",
      "average": "O(1)",
      "worst": "O(1)"
    },
    "stable": "NO"
  },
  "MergeSort": {
    "title": "Merge Sort",
    "metaTitle": "Merge Sort | Algoviz",
    "description": "Merge Sort is a Divide and Conquer algorithm. It divides input array in two halves, calls itself for the two halves and then merges the two sorted halves.",
    "code": "void merge(int arr[], int l, int m, int r){\n\tint i, j, k;\n\tint n1 = m - l + 1;\n\tint n2 = r - m;\n\tint L[n1], R[n2];\n\tfor (i = 0; i < n1; i++) L[i] = arr[l + i];\n\tfor (j = 0; j < n2; j++) R[j] = arr[m + 1 + j];\n\ti = 0;\n\tj = 0;\n\tk = l;\n\twhile (i < n1 && j < n2){\n\t\tif (L[i] <= R[j]){\n\t\t\tarr[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse{\n\t\t\tarr[k] = R[j];\n\t\t\tj++;\n\t\t}\n\t\tk++;\n\t}\n\twhile (i < n1){\n\t\tarr[k] = L[i];\n\t\ti++;\n\t\tk++;\n\t}\n\twhile (j < n2){\n\t\tarr[k] = R[j];\n\t\tj++;\n\t\tk++;\n\t}\n}\nvoid mergeSort(int arr[], int l, int r){\n\tif (l < r){\n\t\tint m = l + (r - l) / 2;\n\t\tmergeSort(arr, l, m);\n\t\tmergeSort(arr, m + 1, r);\n\t\tmerge(arr, l, m, r);\n\t}\n}",
    "timeComplexity": {
      "best": "O(n log(n))",
      "average": "O(n log(n))",
      "worst": "O(n log(n))"
    },
    "spaceComplexity": {
      "best": "O(n)",
      "average": "O(n)",
      "worst": "O(n)"
    },
    "stable": "YES"
  },
  "QuickSort": {
    "title": "Quick Sort",
    "metaTitle": "Quick Sort | Algoviz",
    "description": "QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot.",
    "code": "int partition(int arr[], int low, int high){\n\tint pivot = arr[high];\n\tint i = (low - 1);\n\tfor (int j = low; j <= high - 1; j++){\n\t\tif (arr[j] < pivot){\n\t\t\ti++;\n\t\t\tswap(&arr[i], &arr[j]);\n\t\t}\n\t}\n\tswap(&arr[i + 1], &arr[high]);\n\treturn (i + 1);\n}\nvoid quickSort(int arr[], int low, int high){\n\tif (low < high){\n\t\tint pi = partition(arr, low, high);\n\t\tquickSort(arr, low, pi - 1);\n\t\tquickSort(arr, pi + 1, high);\n\t}\n}",
    "timeComplexity": {
      "best": "O(n log(n))",
      "average": "O(n log(n))",
      "worst": "O(n^2)"
    },
    "spaceComplexity": {
      "best": "O(log(n))",
      "average": "O(log(n))",
      "worst": "O(n)"
    },
    "stable": "NO"
  },
  "HeapSort": {
    "title": "Heap Sort",
    "metaTitle": "Heap Sort | Algoviz",
    "description": "Heap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end.",
    "code": "void heapify(int arr[], int n, int i){\n\tint largest = i;\n\tint l = 2 * i + 1;\n\tint r = 2 * i + 2;\n\tif (l < n && arr[l] > arr[largest]) largest = l;\n\tif (r < n && arr[r] > arr[largest]) largest = r;\n\tif (largest != i){\n\t\tswap(&arr[i], &arr[largest]);\n\t\theapify(arr, n, largest);\n\t}\n}\nvoid heapSort(int arr[], int n){\n\tfor (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);\n\tfor (int i = n - 1; i >= 0; i--){\n\t\tswap(&arr[0], &arr[i]);\n\t\theapify(arr, i, 0);\n\t}\n}",
    "timeComplexity": {
      "best": "O(n log(n))",
      "average": "O(n log(n))",
      "worst": "O(n log(n))"
    },
    "spaceComplexity": {
      "best": "O(1)",
      "average": "O(1)",
      "worst": "O(1)"
    },
    "stable": "NO"
  },
  "RadixSort": {
    "title": "Radix Sort",
    "metaTitle": "Radix Sort | Algoviz",
    "description": "Radix sort is a sorting technique that sorts the elements by first grouping the individual digits of the same place value. Then, sort the elements according to their increasing/decreasing order.",
    "code": "int getMax(int arr[], int n){\n\tint mx = arr[0];\n\tfor (int i = 1; i < n; i++)\n\t\tif (arr[i] > mx)\n\t\t\tmx = arr[i];\n\treturn mx;\n}\nvoid countSort(int arr[], int n, int exp){\n\tint output[n];\n\tint i, count[10] = {0};\n\tfor (i = 0; i < n; i++) count[(arr[i] / exp) % 10]++;\n\tfor (i = 1; i < 10; i++) count[i] += count[i - 1];\n\tfor (i = n - 1; i >= 0; i--){\n\t\toutput[count[(arr[i] / exp) % 10] - 1] = arr[i];\n\t\tcount[(arr[i] / exp) % 10]--;\n\t}\n\tfor (i = 0; i < n; i++) arr[i] = output[i];\n}\nvoid radixSort(int arr[], int n){\n\tint m = getMax(arr, n);\n\tfor (int exp = 1; m / exp > 0; exp *= 10)\n\t\tcountSort(arr, n, exp);\n}",
    "timeComplexity": {
      "best": "O(nk)",
      "average": "O(nk)",
      "worst": "O(nk)"
    },
    "spaceComplexity": {
      "best": "O(n + k)",
      "average": "O(n + k)",
      "worst": "O(n + k)"
    },
    "stable": "YES"
  },
  "LinearSearch": {
    "title": "Linear Search",
    "metaTitle": "Linear Search | Algoviz",
    "description": "Linear search is a very simple search algorithm. In this type of search, a sequential search is made over all items one by one. Every item is checked and if a match is found then that particular item is returned, otherwise the search continues till the end of the data collection.",
    "code": "int linearSearch(int arr[], int n, int x){\n\tint i;\n\tfor (i = 0; i < n; i++)\n\t\tif (arr[i] == x)\n\t\t\treturn i;\n\treturn -1;\n}",
    "timeComplexity": {
      "best": "O(1)",
      "average": "O(n)",
      "worst": "O(n)"
    },
    "spaceComplexity": {
      "best": "O(1)",
      "average": "O(1)",
      "worst": "O(1)"
    }
  },
  "BinarySearch": {
    "title": "Binary Search",
    "metaTitle": "Binary Search | Algoviz",
    "description": "Binary search is a search algorithm that finds the position of a target value within a sorted array.",
    "code": "int binarySearch(int arr[], int l, int r, int x){\n\tif (r >= l){\n\t\tint mid = l + (r - l) / 2;\n\t\tif (arr[mid] == x)\n\t\t\treturn mid;\n\t\tif (arr[mid] > x)\n\t\t\treturn binarySearch(arr, l, mid - 1, x);\n\t\treturn binarySearch(arr, mid + 1, r, x);\n\t}\n\treturn -1;\n}",
    "timeComplexity": {
      "best": "O(1)",
      "average": "O(log(n))",
      "worst": "O(log(n))"
    },
    "spaceComplexity": {
      "best": "O(1)",
      "average": "O(1)",
      "worst": "O(1)"
    }
  },
  "JumpSearch": {
    "title": "Jump Search",
    "metaTitle": "Jump Search | Algoviz",
    "description": "Jump Search is a searching algorithm for sorted arrays. The basic idea is to check fewer elements (than linear search) by jumping ahead by fixed steps or skipping some elements in place of searching all elements.",
    "code": "int jumpSearch(int arr[], int x, int n){\n\tint step = sqrt(n);\n\tint prev = 0;\n\twhile (arr[min(step, n) - 1] < x){\n\t\tprev = step;\n\t\tstep += sqrt(n);\n\t\tif (prev >= n)\n\t\t\treturn -1;\n\t}\n\twhile (arr[prev] < x){\n\t\tprev++;\n\t\tif (prev == min(step, n))\n\t\t\treturn -1;\n\t}\n\tif (arr[prev] == x)\n\t\treturn prev;\n\treturn -1;\n}",
    "timeComplexity": {
      "best": "O(1)",
      "average": "O(√n)",
      "worst": "O(√n)"
    },
    "spaceComplexity": {
      "best": "O(1)",
      "average": "O(1)",
      "worst": "O(1)"
    }
  },
  "InterpolationSearch": {
    "title": "Interpolation Search",
    "metaTitle": "Interpolation Search | Algoviz",
    "description": "Interpolation search is an improvement over binary search for instances, where the values in a sorted array are uniformly distributed. Binary search always goes to the middle element to check. On the other hand, interpolation search may go to different locations according to the value of the key being searched.",
    "code": "int interpolationSearch(int arr[], int n, int x){\n\tint lo = 0, hi = (n - 1);\n\twhile (lo <= hi && x >= arr[lo] && x <= arr[hi]){\n\t\tif (lo == hi){\n\t\t\tif (arr[lo] == x) return lo;\n\t\t\treturn -1;\n\t\t}\n\t\tint pos = lo + (((double)(hi - lo) / \n\t\t(arr[hi] - arr[lo])) * (x - arr[lo]));\n\n\t\tif (arr[pos] == x)\n\t\t\treturn pos;\n\t\tif (arr[pos] < x)\n\t\t\tlo = pos + 1;\n\t\telse\n\t\t\thi = pos - 1;\n\t}\n\treturn -1;\n}",
    "timeComplexity": {
      "best": "O(1)",
      "average": "O(log(log(n)))",
      "worst": "O(n)"
    },
    "spaceComplexity": {
      "best": "O(1)",
      "average": "O(1)",
      "worst": "O(1)"
    }
  },
  "DepthFirstSearch": {
    "title": "Depth First Search",
    "metaTitle": "Depth First Search | Algoviz",
    "description": "Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. One starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.",
    "code": "void DFS(int v){\n\tvisited[v] = true;\n\tcout << v << \" \";\n\tfor (int u: adj[v])\n\t\tif (!visited[u])\n\t\t\tDFS(u);\n}",
    "timeComplexity": {
      "best": "O(V + E)",
      "average": "O(V + E)",
      "worst": "O(V + E)"
    },
    "spaceComplexity": {
      "best": "O(V)",
      "average": "O(V)",
      "worst": "O(V)"
    }
  },
  "BreadthFirstSearch": {
    "title": "Breadth First Search",
    "metaTitle": "Breadth First Search | Algoviz",
    "description": "Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key') and explores the neighbor nodes first, before moving to the next level neighbors.",
    "code": "void BFS(int s){\n\tbool *visited = new bool[V];\n\tfor (int i = 0; i < V; i++)\n\t\tvisited[i] = false;\n\tlist<int> queue;\n\tvisited[s] = true;\n\tqueue.push_back(s);\n\tlist<int>::iterator i;\n\twhile (!queue.empty()){\n\t\ts = queue.front();\n\t\tcout << s << \" \";\n\t\tqueue.pop_front();\n\t\tfor (i = adj[s].begin(); i != adj[s].end(); ++i){\n\t\t\tif (!visited[*i]){\n\t\t\t\tvisited[*i] = true;\n\t\t\t\tqueue.push_back(*i);\n\t\t\t}\n\t\t}\n\t}\n}",
    "timeComplexity": {
      "best": "O(V + E)",
      "average": "O(V + E)",
      "worst": "O(V + E)"
    },
    "spaceComplexity": {
      "best": "O(V)",
      "average": "O(V)",
      "worst": "O(V)"
    }
  },
  "AStar": {
    "title": "A* Search Algorithm",
    "metaTitle": "A* Search Algorithm | Algoviz",
    "description": "A* (pronounced as 'A star') is a computer algorithm that is widely used in pathfinding and graph traversal, the process of plotting an efficiently traversable path between multiple points, called nodes.",
    "code": "void aStarSearch(){\n\tint i, j, x, y, x1, y1, x2, y2;\n\tfor (i = 0; i < n; i++)\n\t\tfor (j = 0; j < n; j++)\n\t\t\tvisited[i][j] = false;\n\tcout << \"Enter the coordinates of the starting point : \";\n\tcin >> x1 >> y1;\n\tcout << \"Enter the coordinates of the ending point : \";\n\tcin >> x2 >> y2;\n\tcout << \"The path is : \" << endl;\n\tvisited[x1][y1] = true;\n\tq.push(make_pair(x1, y1));\n\twhile (!q.empty()){\n\t\tx = q.front().first;\n\t\ty = q.front().second;\n\t\tq.pop();\n\t\tif (x == x2 && y == y2)\n\t\t\tbreak;\n\t\tfor (i = 0; i < 4; i++){\n\t\t\tx1 = x + dx[i];\n\t\t\ty1 = y + dy[i];\n\t\t\tif (isValid(x1, y1) && !visited[x1][y1]){\n\t\t\t\tvisited[x1][y1] = true;\n\t\t\t\tq.push(make_pair(x1, y1));\n\t\t\t\tp[x1][y1] = make_pair(x, y);\n\t\t\t}\n\t\t}\n\t}\n\tprintPath(x2, y2);\n}",
    "timeComplexity": {
      "best": "O(b^d)",
      "average": "O(b^d)",
      "worst": "O(b^d)"
    },
    "spaceComplexity": {
      "best": "O(b^d)",
      "average": "O(b^d)",
      "worst": "O(b^d)"
    }
  },
  "Prim": {
    "title": "Prim's Algorithm",
    "metaTitle": "Prim's Algorithm | Algoviz",
    "description": "Prim's algorithm finds a minimum spanning tree (MST) for a connected weighted undirected graph by growing the MST one edge at a time, always picking the lowest-weight edge that connects a vertex in the tree to a vertex outside it.",
    "code": "void primMST(int graph[V][V]) {\n\tint parent[V], key[V];\n\tbool mstSet[V];\n\tfor (int i = 0; i < V; i++) {\n\t\tkey[i] = INT_MAX;\n\t\tmstSet[i] = false;\n\t}\n\tkey[0] = 0;\n\tparent[0] = -1;\n\tfor (int count = 0; count < V - 1; count++) {\n\t\tint u = -1, minKey = INT_MAX;\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tif (!mstSet[v] && key[v] < minKey) {\n\t\t\t\tminKey = key[v];\n\t\t\t\tu = v;\n\t\t\t}\n\t\t}\n\t\tmstSet[u] = true;\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tif (graph[u][v] && !mstSet[v] && graph[u][v] < key[v]) {\n\t\t\t\tparent[v] = u;\n\t\t\t\tkey[v] = graph[u][v];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < V; i++)\n\t\tprintf(\"%d - %d\\tweight=%d\\n\", parent[i], i, graph[i][parent[i]]);\n}",
    "timeComplexity": {
      "best": "O(E + V log V) (with heap)",
      "average": "O(E + V log V)",
      "worst": "O(E + V log V)"
    },
    "spaceComplexity": {
      "best": "O(V)",
      "average": "O(V)",
      "worst": "O(V)"
    }
  },
  "Kruskal": {
    "title": "Kruskal's Algorithm",
    "metaTitle": "Kruskal's Algorithm | Algoviz",
    "description": "Kruskal's algorithm finds a minimum spanning tree (MST) for a connected weighted undirected graph by sorting all edges by weight and greedily adding them to the MST if they don't form a cycle (detected using Union-Find).",
    "code": "class UnionFind {\npublic:\n\tvector<int> parent, rank;\n\tUnionFind(int n) {\n\t\tparent.resize(n);\n\t\trank.assign(n, 0);\n\t\tfor (int i = 0; i < n; i++) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] != x) parent[x] = find(parent[x]);\n\t\treturn parent[x];\n\t}\n\tbool unite(int x, int y) {\n\t\tint px = find(x), py = find(y);\n\t\tif (px == py) return false;\n\t\tif (rank[px] < rank[py]) swap(px, py);\n\t\tparent[py] = px;\n\t\tif (rank[px] == rank[py]) rank[px]++;\n\t\treturn true;\n\t}\n};\nvoid kruskalMST(vector<Edge>& edges, int V) {\n\tsort(edges.begin(), edges.end(), [](Edge& a, Edge& b) {\n\t\treturn a.weight < b.weight;\n\t});\n\tUnionFind uf(V);\n\tint mstWeight = 0;\n\tfor (auto& e : edges) {\n\t\tif (uf.unite(e.u, e.v)) {\n\t\t\tcout << e.u << \" - \" << e.v << \" : \" << e.weight << endl;\n\t\t\tmstWeight += e.weight;\n\t\t}\n\t}\n\tcout << \"MST Weight: \" << mstWeight << endl;\n}",
    "timeComplexity": {
      "best": "O(E log E)",
      "average": "O(E log E)",
      "worst": "O(E log E)"
    },
    "spaceComplexity": {
      "best": "O(V)",
      "average": "O(V)",
      "worst": "O(V)"
    }
  },
  "Dijkstra": {
    "title": "Dijkstra's Algorithm",
    "metaTitle": "Dijkstra's Algorithm | Algoviz",
    "description": "Dijkstra's algorithm finds the shortest path from a source node to all other nodes in a weighted graph with non-negative edge weights. It uses a greedy approach with a priority queue.",
    "code": "void dijkstra(int graph[V][V], int src) {\n\tint dist[V];\n\tbool sptSet[V];\n\tfor (int i = 0; i < V; i++)\n\t\tdist[i] = INT_MAX, sptSet[i] = false;\n\tdist[src] = 0;\n\tfor (int count = 0; count < V - 1; count++) {\n\t\tint u = -1;\n\t\tint minDist = INT_MAX;\n\t\tfor (int v = 0; v < V; v++)\n\t\t\tif (!sptSet[v] && dist[v] < minDist)\n\t\t\t\tminDist = dist[v], u = v;\n\t\tsptSet[u] = true;\n\t\tfor (int v = 0; v < V; v++)\n\t\t\tif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX\n\t\t\t\t&& dist[u] + graph[u][v] < dist[v])\n\t\t\t\tdist[v] = dist[u] + graph[u][v];\n\t}\n\tfor (int i = 0; i < V; i++)\n\t\tprintf(\"Node %d -> Distance %d\\n\", i, dist[i]);\n}",
    "timeComplexity": {
      "best": "O((V + E) log V) (with heap)",
      "average": "O((V + E) log V)",
      "worst": "O(V^2) (with array)"
    },
    "spaceComplexity": {
      "best": "O(V)",
      "average": "O(V)",
      "worst": "O(V)"
    }
  },
  "BellmanFord": {
    "title": "Bellman-Ford Algorithm",
    "metaTitle": "Bellman-Ford Algorithm | Algoviz",
    "description": "The Bellman-Ford algorithm finds the shortest path from a source node to all other nodes in a weighted graph. It handles negative edge weights and detects negative cycles.",
    "code": "void bellmanFord(vector<Edge>& edges, int V, int src) {\n\tvector<int> dist(V, INT_MAX);\n\tdist[src] = 0;\n\tfor (int i = 0; i < V - 1; i++) {\n\t\tfor (auto& e : edges) {\n\t\t\tif (dist[e.u] != INT_MAX && dist[e.u] + e.weight < dist[e.v])\n\t\t\t\tdist[e.v] = dist[e.u] + e.weight;\n\t\t}\n\t}\n\tfor (auto& e : edges) {\n\t\tif (dist[e.u] != INT_MAX && dist[e.u] + e.weight < dist[e.v])\n\t\t\tcout << \"Negative cycle detected!\\n\";\n\t}\n\tfor (int i = 0; i < V; i++)\n\t\tprintf(\"Node %d -> Distance %d\\n\", i, dist[i]);\n}",
    "timeComplexity": {
      "best": "O(VE)",
      "average": "O(VE)",
      "worst": "O(VE)"
    },
    "spaceComplexity": {
      "best": "O(V)",
      "average": "O(V)",
      "worst": "O(V)"
    }
  },
  "FloydWarshall": {
    "title": "Floyd-Warshall Algorithm",
    "metaTitle": "Floyd-Warshall Algorithm | Algoviz",
    "description": "The Floyd-Warshall algorithm computes shortest paths between all pairs of nodes in a weighted graph. It handles negative weights (but not negative cycles) and is useful for dense graphs.",
    "code": "void floydWarshall(int graph[V][V]) {\n\tint dist[V][V];\n\tfor (int i = 0; i < V; i++)\n\t\tfor (int j = 0; j < V; j++)\n\t\t\tdist[i][j] = graph[i][j];\n\tfor (int k = 0; k < V; k++) {\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tfor (int j = 0; j < V; j++) {\n\t\t\t\tif (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX\n\t\t\t\t\t&& dist[i][k] + dist[k][j] < dist[i][j])\n\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < V; i++)\n\t\tfor (int j = 0; j < V; j++)\n\t\t\tprintf(\"%d -> %d: %d\\n\", i, j, dist[i][j]);\n}",
    "timeComplexity": {
      "best": "O(V^3)",
      "average": "O(V^3)",
      "worst": "O(V^3)"
    },
    "spaceComplexity": {
      "best": "O(V^2)",
      "average": "O(V^2)",
      "worst": "O(V^2)"
    }
  },
  "Minimax": {
    "title": "Minimax with Alpha-Beta Pruning",
    "metaTitle": "Minimax with Alpha-Beta Pruning | Algoviz",
    "description": "Minimax is a game tree search algorithm that chooses the optimal move by assuming an optimal adversary, while alpha-beta pruning eliminates branches that cannot influence the final decision.",
    "code": "int minimax(Node node, int depth, int alpha, int beta, bool maximizingPlayer){\n\tif (depth == 0 || node.isTerminal())\n\t\treturn node.evaluate();\n\tif (maximizingPlayer){\n\t\tint bestValue = NEG_INF;\n\t\tfor (Node child : node.children()){\n\t\t\tint value = minimax(child, depth - 1, alpha, beta, false);\n\t\t\tbestValue = max(bestValue, value);\n\t\t\talpha = max(alpha, value);\n\t\t\tif (beta <= alpha) break; // beta cut-off\n\t\t}\n\t\treturn bestValue;\n\t}else{\n\t\tint bestValue = POS_INF;\n\t\tfor (Node child : node.children()){\n\t\t\tint value = minimax(child, depth - 1, alpha, beta, true);\n\t\t\tbestValue = min(bestValue, value);\n\t\t\tbeta = min(beta, value);\n\t\t\tif (beta <= alpha) break; // alpha cut-off\n\t\t}\n\t\treturn bestValue;\n\t}\n}",
    "timeComplexity": {
      "best": "O(b^{d/2})",
      "average": "O(b^d)",
      "worst": "O(b^d)"
    },
    "spaceComplexity": {
      "best": "O(bd)",
      "average": "O(bd)",
      "worst": "O(bd)"
    }
  }
}
